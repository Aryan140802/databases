import os
import re
import traceback
import pymysql
import sqlparse
from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

# --- Configuration ---

# Database connection details
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "root123",
    "database": "EIS_n"
}

# LLM model to use
LLM_MODEL = "mistral:7b-instruct-q4_K_M"

# --- Database Setup ---

def get_db_connection():
    """Establishes and returns a SQLAlchemy engine for the database."""
    uri = f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}"
    return create_engine(uri)

# Instantiate the database engine
try:
    db_engine = get_db_connection()
    # Test connection
    with db_engine.connect() as connection:
        print("‚úÖ Database connection successful.")
    db = SQLDatabase(engine=db_engine)
except Exception as e:
    print(f"‚ùå Database connection failed. Please check your credentials and ensure the MySQL server is running.")
    print(f"Error: {e}")
    exit()

# --- LLM and Prompt Setup ---

# Initialize the Ollama LLM
llm = OllamaLLM(model=LLM_MODEL)

# --- CORRECTED AND IMPROVED PROMPT ---
# This prompt is more detailed, includes the full schema, and provides better examples
# to guide the LLM into generating more accurate and reliable queries.
sql_prompt_template = """### Instructions
You are an expert AI assistant that generates read-only MySQL queries.
Your ONLY output should be a single, valid MySQL query. Do not add any explanation, commentary, or markdown formatting like ```sql.

### Rules
1.  **IMPORTANT**: You MUST only generate read-only `SELECT` queries. Never generate `UPDATE`, `DELETE`, `INSERT`, `DROP`, or any other write-modifying queries.
2.  The table name is `EISHome_compliance`.
3.  Use `LIKE` with wildcards (e.g., `%value%`) for string comparisons to allow for partial matches.
4.  For questions about whether all servers share a certain property (e.g., "do all servers have the same os version?"), you MUST generate a query that returns a single value: 'Yes' or 'No'. See the example below.
5.  Analyze the user's question to infer the correct column and values for the `WHERE` clause.
6.  The `upTime` column is a string like '2 weeks 6 days...'. You can only perform simple string searches on it (e.g., `WHERE upTime LIKE '%weeks%'`).

### Table Schema: `EISHome_compliance`
- id (bigint): Unique identifier.
- ip_address (varchar): Server IP address.
- last_update (varchar): Last update timestamp.
- upTime (varchar): Server uptime as a string (e.g., '3 weeks 6 days...').
- server_role (varchar): Role of the server (e.g., 'DR LINUX').
- ram (int): RAM in GB.
- cpuCore (int): Number of CPU cores.
- osVersion (varchar): Operating system version (e.g., '9.6(Plow)').
- kernelVersion (varchar): Linux kernel version (e.g., '5.14.0-570.25.1.el9_6.x86_64').
- aceVersion (varchar): ACE agent version.
- mqVersion (varchar): MQ agent version.
- firewall (varchar): Firewall status ('active', 'inactive').
- rpmCount (int): Count of installed RPM packages.
- dsAgent (varchar): Deep Security agent status.
- splunk (varchar): Splunk agent status.
- fileSystem (varchar): Filesystem status (e.g., 'OK', '/var (81%)').

### Query Examples
- User Question: "Show me all the servers."
  Query: SELECT * FROM EISHome_compliance;
- User Question: "What is the OS version for the server with IP 10.122.41.10?"
  Query: SELECT osVersion FROM EISHome_compliance WHERE ip_address = '10.122.41.10';
- User Question: "show me all servers with more than 4 cores"
  Query: SELECT * FROM EISHome_compliance WHERE cpuCore > 4;
- User Question: "are there any servers with an inactive firewall?"
  Query: SELECT ip_address, firewall FROM EISHome_compliance WHERE firewall = 'inactive';
- User Question: "do all servers have the same ace version?"
  Query: SELECT CASE WHEN COUNT(DISTINCT aceVersion) = 1 THEN 'Yes' ELSE 'No' END as result FROM EISHome_compliance;

### User Question
{question}

### Your MySQL Query
"""

SQL_PROMPT = PromptTemplate.from_template(sql_prompt_template)

# Prompt template for explaining the results to the user
explanation_prompt_template = """### Instructions
You are an AI assistant. A user asked a question, a database query was run, and you have the results.
Your task is to provide a clear, human-like explanation of the data as an answer to the user's question.
If the result is empty or `[]`, inform the user that no matching records were found.
If the result is a single value like 'Yes' or 'No', state that clearly.
Do not mention the database or the query that was run. Just answer the question based on the provided data.

### User's Question
{question}

### Database Result
{result}

### Your Answer
"""

EXPLANATION_PROMPT = PromptTemplate.from_template(explanation_prompt_template)

# --- Core Functions ---

def is_readonly_query(sql_query: str) -> bool:
    """
    Checks if the generated SQL query is a read-only SELECT statement.
    """
    # Sanitize the query to handle potential LLM artifacts like newlines or comments
    sanitized_query = sqlparse.format(sql_query, strip_comments=True).strip()
    if not sanitized_query:
        return False
        
    parsed = sqlparse.parse(sanitized_query)
    if not parsed:
        return False
    
    # Check the first statement's type
    return parsed[0].get_type() == 'SELECT'

# --- LangChain Chains ---

# Chain to generate the SQL query
sql_generation_chain = (
    RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
    | SQL_PROMPT
    | llm
    | StrOutputParser()
)

# Chain to explain the results
explanation_chain = EXPLANATION_PROMPT | llm | StrOutputParser()


# --- Main Application Logic ---

def main():
    """Main function to run the chatbot terminal interface."""
    print("\n--- AI Database Chatbot ---")
    print("Ask questions about your IT infrastructure. Type 'exit' to quit.")

    while True:
        try:
            user_question = input("\n> ")
            if user_question.lower().strip() == 'exit':
                print("Goodbye!")
                break
            
            # --- SIMPLIFIED AND UNIFIED LOGIC FLOW ---
            # The previous version had complex branching. This new version uses a single,
            # more reliable path for all questions.

            # 1. Generate SQL Query
            print("ü§ñ Thinking...")
            generated_sql = sql_generation_chain.invoke({"question": user_question})
            
            # Clean up potential markdown formatting from LLM output
            generated_sql = generated_sql.strip().replace("```sql", "").replace("```", "").strip()
            print(f"üîç Generated SQL: {generated_sql}")

            # 2. Validate the Query
            if not is_readonly_query(generated_sql):
                print("‚ö†Ô∏è Error: Only read-only queries are allowed. Aborting.")
                continue

            # 3. Execute the Query
            db_result = db.run(generated_sql)

            # 4. Generate the Final Answer using the Explanation Chain
            # This single chain can now handle all cases: empty results, 'Yes'/'No' answers,
            # and full data tables, providing a user-friendly response.
            explanation = explanation_chain.invoke({"question": user_question, "result": db_result})
            print(f"\nü§ñ Answer: {explanation}")

        except Exception as e:
            print(f"\nAn unexpected error occurred: {e}")
            traceback.print_exc()
            print("Please try rephrasing your question.")

if __name__ == "__main__":
    main()
