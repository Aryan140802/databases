import os
import re
import traceback
import pymysql
import sqlparse
from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

# --- Configuration ---

# Database connection details
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "root123",
    "database": "EIS_n"
}

# LLM model to use
LLM_MODEL = "mistral:7b-instruct-q4_K_M"

# --- Database Setup ---

def get_db_connection():
    """Establishes and returns a SQLAlchemy engine for the database."""
    uri = f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}"
    return create_engine(uri)

# Instantiate the database engine
try:
    db_engine = get_db_connection()
    # Test connection
    with db_engine.connect() as connection:
        print("‚úÖ Database connection successful.")
    db = SQLDatabase(engine=db_engine)
except Exception as e:
    print(f"‚ùå Database connection failed. Please check your credentials and ensure the MySQL server is running.")
    print(f"Error: {e}")
    exit()

# --- LLM and Prompt Setup ---

# Initialize the Ollama LLM
llm = OllamaLLM(model=LLM_MODEL)

# Detailed prompt template for generating SQL queries
# This prompt includes schema details, rules, and examples to guide the LLM.
sql_prompt_template = """### Instructions
You are an AI assistant that generates read-only MySQL queries for a database with the following schema.
Your ONLY output should be the MySQL query. Do not add any explanation, commentary, or markdown formatting like ```sql.

### Rules
1. **IMPORTANT**: You MUST only generate read-only `SELECT` queries. Never generate `UPDATE`, `DELETE`, `INSERT`, `DROP`, or any other write-modifying queries.
2. The table name is `EISHome_compliance`.
3. Use `LIKE` for string comparisons to allow for partial matches.
4. Analyze the user's question to infer the correct column and values for the `WHERE` clause.
5. Pay close attention to the `upTime` column format (e.g., '1 weeks 6 days 21 hours 3 minutes') when asked about time periods. Use string manipulation functions like `SUBSTRING_INDEX` and `CAST` to extract and compare numerical values for weeks and days.

### Table Schema: `EISHome_compliance`
- id (bigint): Unique identifier for each entry.
- ip_address (varchar): IP address of the server (e.g., '192.168.1.10').
- last_update (varchar): Last update timestamp (e.g., '2025-08-08 10:00:00').
- upTime (varchar): Server uptime (e.g., '30 days'). The format can be 'X weeks Y days ...'
- server_role (varchar): Role of the server (e.g., 'Application Server', 'Database Server').
- ram (int): RAM in GB (e.g., 16 for 16GB).
- cpuCore (int): Number of CPU cores (e.g., 8).
- osVersion (varchar): Operating system version (e.g., 'Red Hat Enterprise Linux 9.2').
- kernelVersion (varchar): Linux kernel version (e.g., '5.14.0-284.11.1.el9_2.x86_64').
- aceVersion (varchar): ACE version (e.g., '12.0.12.10').
- mqVersion (varchar): MQ version (e.g., '9.4.0.11').
- firewall (varchar): Firewall status (e.g., 'active', 'inactive').
- rpmCount (int): Count of installed RPM packages.
- dsAgent (varchar): Deep Security agent status (e.g., 'DSrunning').
- splunk (varchar): Splunk agent status (e.g., 'SPLrunning').
- ragent (varchar): R Agent status (e.g., 'undefined').
- eisuserExpi (varchar): Expiration date for the eisuser (e.g., 'Oct 04 2025').
- rootExpi (varchar): Expiration date for the root user (e.g., 'Nov 01 2025').
- socvaExpi (varchar): Expiration date for the socva user (e.g., 'Oct 03 2025').
- addmitamExpi (varchar): Expiration date for the addmitam user (e.g., 'Nov 01 2025').
- systemTime (varchar): System time difference from NTP (e.g., '0.000111858 seconds fast of NTP time').
- fileSystem (varchar): File system status (e.g., 'OK', '/var (81%)').
- cpu (int): CPU usage percentage (e.g., 8).
- mem_cp_update (varchar): Memory and CPU update timestamp (e.g., 'Aug 8 12:32').
- memory (int): Memory usage percentage (e.g., 34).

### Query Examples
- Question: "What is the OS version for the server with IP 10.0.2.5?"
  Query: SELECT osVersion FROM EISHome_compliance WHERE ip_address = '10.0.2.5';
- Question: "show me all servers with more than 8 cores"
  Query: SELECT * FROM EISHome_compliance WHERE cpuCore > 8;
- Question: "are there any servers with firewall disabled?"
  Query: SELECT id FROM EISHome_compliance WHERE firewall = 'disabled';
- Question: "are all servers compliant with the latest ace version?"
  Query: SELECT COUNT(DISTINCT aceVersion) AS unique_ace_versions FROM EISHome_compliance;
- Question: "give me the ip address of the server whose uptime is more than 2 weeks"
  Query: SELECT ip_address FROM EISHome_compliance WHERE CAST(SUBSTRING_INDEX(upTime, ' ', 1) AS UNSIGNED) > 2 AND upTime LIKE '%weeks%';

### User Question
{question}

### Your MySQL Query
"""

SQL_PROMPT = PromptTemplate.from_template(sql_prompt_template)

# Prompt template for explaining the results to the user
explanation_prompt_template = """### Instructions
You are an AI assistant. A user asked a question, a database query was run, and you have the results.
Your task is to provide a clear, human-like explanation of the data as an answer to the user's question.
If the result is empty, inform the user that no matching records were found. Do not mention the database or the query.

### User's Question
{question}

### Database Result
{result}

### Your Answer
"""

EXPLANATION_PROMPT = PromptTemplate.from_template(explanation_prompt_template)


# --- Core Functions ---

def is_readonly_query(sql_query: str) -> bool:
    """
    Checks if the generated SQL query is a read-only SELECT statement.
    """
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return False
    # Check the first statement's type
    return parsed[0].get_type() == 'SELECT'

def get_yes_no_answer(db_result: str) -> str:
    """
    Determines the 'Yes' or 'No' answer based on whether the query returned any data.
    An empty result (e.g., '[]') means 'No', otherwise 'Yes'.
    """
    # The db.run() method returns a string representation of a list of tuples.
    # An empty result looks like '[]'.
    if db_result and db_result.strip() not in ('[]', ''):
        # A result like '[('1',)]' or '[('Yes',)]' is a "Yes"
        # We can also check for specific values if needed
        # For 'SELECT COUNT...' queries, if the count is > 1, the answer is 'No' for "are all the same" questions.
        # This requires more advanced parsing, so we'll stick to a simpler check here
        return "Yes"
    else:
        return "No"

# --- LangChain Chains ---

# Chain to generate the SQL query
sql_generation_chain = (
    RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
    | SQL_PROMPT
    | llm
    | StrOutputParser()
)

# Chain to explain the results
explanation_chain = EXPLANATION_PROMPT | llm | StrOutputParser()


# --- Main Application Logic ---

def main():
    """Main function to run the chatbot terminal interface."""
    print("\n--- AI Database Chatbot ---")
    print("Ask questions about your IT infrastructure. Type 'exit' to quit.")

    # Words that might trigger a 'yes/no' response, but the logic should be more robust
    yes_no_starters = ('is', 'are', 'do', 'does', 'did', 'has', 'have', 'do')
    # Words that indicate a comparison question, which should use the explanation chain
    comparison_words = ('all', 'same', 'different')

    while True:
        try:
            user_question = input("\n> ")
            if user_question.lower().strip() == 'exit':
                print("Goodbye!")
                break

            # 1. Generate SQL Query
            print("ü§ñ Thinking...")
            generated_sql = sql_generation_chain.invoke({"question": user_question})

            # Clean up potential markdown formatting from LLM output
            generated_sql = generated_sql.strip().replace("```sql", "").replace("```", "").strip()
            print(f"üîç Generated SQL: {generated_sql}")

            # 2. Validate the Query
            if not is_readonly_query(generated_sql):
                print("‚ö†Ô∏è Error: Only read-only queries are allowed. Aborting.")
                continue

            # 3. Execute the Query
            db_result = db.run(generated_sql)

            # 4. Generate the Final Answer
            # A more nuanced check for "yes/no" questions
            if any(user_question.lower().strip().startswith(s) for s in yes_no_starters) and not any(w in user_question.lower() for w in comparison_words):
                answer = get_yes_no_answer(db_result)
                print(f"\nü§ñ Answer: {answer}")
            else:
                # For descriptive questions, use the explanation chain
                explanation = explanation_chain.invoke({"question": user_question, "result": db_result})
                print(f"\nü§ñ Answer: {explanation}")

        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            print("Please try rephrasing your question.")
            traceback.print_exc()

if __name__ == "__main__":
    main()
