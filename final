import os
import re
import traceback
import pymysql
import sqlparse
from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

# --- Configuration ---

# [cite: 58] Database connection details
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "root123",
    "database": "EIS_n"
}

# LLM model to use
LLM_MODEL = "myllm:latest"

# --- Database Setup ---

def get_db_connection():
    """Establishes and returns a SQLAlchemy engine for the database."""
    uri = f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}"
    return create_engine(uri)

# Instantiate the database engine
try:
    db_engine = get_db_connection()
    # Test connection
    with db_engine.connect() as connection:
        print("‚úÖ Database connection successful.")
    db = SQLDatabase(engine=db_engine)
except Exception as e:
    print(f"‚ùå Database connection failed. Please check your credentials and ensure the MySQL server is running.")
    print(f"Error: {e}")
    exit()

# --- LLM and Prompt Setup ---

# Initialize the Ollama LLM
llm = OllamaLLM(model=LLM_MODEL)

# [cite: 27, 29, 30] Detailed prompt template for generating SQL queries
# This prompt includes schema details, rules, and examples to guide the LLM.
sql_prompt_template = """### Instructions
You are an AI assistant that generates read-only MySQL queries for a database with the following schema.
Your ONLY output should be the MySQL query. Do not add any explanation, commentary, or markdown formatting like ```sql.

### Rules
1.   **IMPORTANT**: You MUST only generate read-only `SELECT` queries. Never generate `UPDATE`, `DELETE`, `INSERT`, `DROP`, or any other write-modifying queries.
2.  The table name is `EISHome_compliance`.
3.  Use `LIKE` for string comparisons to allow for partial matches.
4.  Analyze the user's question to infer the correct column and values for the `WHERE` clause.

### Table Schema: `EISHome_compliance`
- id (bigint): Unique identifier for each entry.
- ip_address (varchar): IP address of the server (e.g., '10.177.40.10').
- last_update (varchar): Last update timestamp (e.g., '2025-08-08 10:00:00 AM').
- upTime (varchar): Server uptime (e.g., '2 weeks 6 days 23 hours 3 minutes').
- server_role (varchar): Role of the server (e.g., 'DR LINUX').
- ram (int): RAM in GB (e.g., 64).
- cpuCore (int): Number of CPU cores (e.g., 8).
- osVersion (varchar): Operating system version (e.g., '9.6(Plow)').
- kernelUdate (varchar): Kernel update date (e.g., 'Sat Jun EDT 28').
- aceVersion (varchar): ACE version (e.g., '12.0.12.10').
- mqVersion (varchar): MQ version (e.g., '9.4.0.11').
- firewall (varchar): Firewall status (e.g., 'active').
- rpmCount (int): Count of installed RPM packages (e.g., 600).
- dsAgent (varchar): DS agent status (e.g., 'DSrunning').
- splunk (varchar): splunk (e.g., 'SPLrunning').
- ragent (varchar): ragent (e.g., 'SPLrunning').
- eisuserExpi (varchar): eisuser expiry (e.g., 'Oct 12 2025').
- rootExpi (varchar): root expiry (e.g., 'Oct 09 2025').
- socvaExpi (varchar): socva expiry (e.g., 'Oct 12 2025').
- addmitamExpi (varchar): addmitam expiry (e.g., 'Nov 01 2025').
- systemTime (varchar): system time (e.g., '0.000032217 seconds fast of NTP time').
- fileSystem (varchar): filesystem (e.g., 'OK').
- kernelVersion (varchar): Linux kernel version (e.g., '5.14.0-570.25.1.el9_6.x86_64').
- cpu (int): cpu usage (e.g., 6).
- mem_cp_update (varchar): memory capacity updated date (e.g., 'Aug 8 17:46').
- memory (int): memory usage (e.g., 37).

### Query Examples
- Question: "What is the OS version for the server with IP 10.177.40.10?"
  Query: SELECT osVersion FROM EISHome_compliance WHERE ip_address like '%10.177.40.10%';
- Question: "show me all servers with more than 4 cores"
  Query: SELECT ip_address FROM EISHome_compliance WHERE cpuCore > 4;
- Question: "which are the servers with firewall disabled?"
  Query: SELECT ip_address FROM EISHome_compliance WHERE firewall = 'inactive';

### User Question
{question}

### Your MySQL Query
"""

SQL_PROMPT = PromptTemplate.from_template(sql_prompt_template)

# Prompt template for explaining the results to the user
explanation_prompt_template = """### Instructions
You are an AI assistant. A user asked a question, a database query was run, and you have the results.
Your task is to provide a clear, human-like explanation of the data as an answer to the user's question.
If the result is empty, inform the user that no matching records were found. Do not mention the database or the query.

### User's Question
{question}

### Database Result
{result}

### Your Answer
"""

EXPLANATION_PROMPT = PromptTemplate.from_template(explanation_prompt_template)


# --- Core Functions ---

def is_readonly_query(sql_query: str) -> bool:
    """
    Checks if the generated SQL query is a read-only SELECT statement.
    """
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return False
    # Check the first statement's type
    return parsed[0].get_type() == 'SELECT'

def get_yes_no_answer(db_result: list) -> str:
    """
    Determines the 'Yes' or 'No' answer based on whether the query returned any data.
    An empty result (e.g., []) means 'No', otherwise 'Yes'.
    """
    # The db.run() method returns a string representation of a list of tuples.
    # An empty result looks like '[]' or an empty string.
    if db_result and db_result != '[]':
        return "Yes"
    else:
        return "No"

# --- LangChain Chains ---

# Chain to generate the SQL query
sql_generation_chain = (
    RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
    | SQL_PROMPT
    | llm
    | StrOutputParser()
)

# Chain to explain the results
explanation_chain = EXPLANATION_PROMPT | llm | StrOutputParser()


# --- Main Application Logic ---

def main():
    """Main function to run the chatbot terminal interface."""
    print("\n--- AI Database Chatbot ---")
    print("Ask questions about your IT infrastructure. Type 'exit' to quit.")

    #  Words that trigger a "Yes/No" response
    yes_no_starters = ('is', 'are', 'do', 'does', 'did', 'has', 'have')

    while True:
        try:
            user_question = input("\n> ")
            if user_question.lower().strip() == 'exit':
                print("Goodbye!")
                break

            # Determine response type based on the question's first word
            is_yes_no_question = user_question.lower().strip().startswith(yes_no_starters)

            # 1. Generate SQL Query
            print("ü§ñ Thinking...")
            generated_sql = sql_generation_chain.invoke({"question": user_question})

            # Clean up potential markdown formatting from LLM output
            generated_sql = generated_sql.strip().replace("```sql", "").replace("```", "").strip()
            print(f"üîç Generated SQL: {generated_sql}")

            # 2. Validate the Query
            if not is_readonly_query(generated_sql):
                print("‚ö†Ô∏è Error: Only read-only queries are allowed. Aborting.")
                continue

            # 3. Execute the Query
            db_result = db.run(generated_sql)

            # 4. Generate the Final Answer
            if is_yes_no_question:
                answer = get_yes_no_answer(db_result)
                print(f"\nü§ñ Answer: {answer}")
            else:
                # For descriptive questions, use the explanation chain
                explanation = explanation_chain.invoke({"question": user_question, "result": db_result})
                print(f"\nü§ñ Answer: {explanation}")

        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            print("Please try rephrasing your question.")

if __name__ == "__main__":
    main()

