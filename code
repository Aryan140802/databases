import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

today_date = date.today()

# --- SYSTEM COMPLIANCE CONFIGURATION ---
COMPLIANCE_DB_CONFIG = {
    "name": "System Compliance",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["EISHome_compliance"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

def detect_yes_no_question(question: str) -> bool:
    """Detect if the question requires a yes/no answer"""
    question_lower = question.lower().strip()
    
    # Common yes/no question patterns
    yes_no_patterns = [
        r"\b(do|does|did|is|are|was|were|will|would|can|could|should|has|have|had)\b.*\?",
        r"\b(all|every|each).*\b(have|has|same|identical|similar)\b",
        r"\b(any|some).*\b(have|has|missing|lacking|contain)\b",
        r"\b(is there|are there|exists?)\b",
        r"\bwhether\b.*\b(all|any|same)\b"
    ]
    
    return any(re.search(pattern, question_lower) for pattern in yes_no_patterns)

def analyze_for_yes_no_answer(question: str, result: List[Dict]) -> Optional[str]:
    """Analyze query results to provide yes/no answers"""
    if not result:
        return "**No** - No servers found matching the criteria."
    
    question_lower = question.lower()
    
    # Check for "all servers have same X" type questions
    same_patterns = [
        (r"(all|every).*same.*kernel.*version", 'kernelVersion'),
        (r"(all|every).*same.*os.*version", 'osVersion'),
        (r"(all|every).*same.*ace.*version", 'aceVersion'),
        (r"(all|every).*same.*mq.*version", 'mqVersion'),
        (r"(all|every).*same.*ram", 'ram'),
        (r"(all|every).*same.*cpu.*core", 'cpuCore'),
        (r"(all|every).*same.*firewall.*status", 'firewall'),
        (r"(all|every).*same.*server.*role", 'server_role')
    ]
    
    for pattern, field in same_patterns:
        if re.search(pattern, question_lower) and field in result[0]:
            # Check if all values are the same
            values = [record.get(field) for record in result if record.get(field) is not None]
            if not values:
                return f"**No** - No {field.replace('_', ' ')} data available."
            
            unique_values = set(values)
            if len(unique_values) == 1:
                return f"**Yes** - All {len(result)} servers have the same {field.replace('_', ' ')}: {list(unique_values)[0]}"
            else:
                return f"**No** - Servers have different {field.replace('_', ' ')} values: {', '.join(map(str, unique_values))}"
    
    # Check for "all servers have X enabled/active" type questions
    status_patterns = [
        (r"(all|every).*firewall.*(active|enabled|running)", 'firewall', ['active', 'enabled', 'running']),
        (r"(all|every).*dsagent.*(active|enabled|running)", 'dsAgent', ['active', 'enabled', 'running']),
        (r"(all|every).*splunk.*(active|enabled|running)", 'splunk', ['active', 'enabled', 'running']),
        (r"(all|every).*firewall.*(disabled|inactive|stopped)", 'firewall', ['disabled', 'inactive', 'stopped']),
        (r"(all|every).*dsagent.*(disabled|inactive|stopped)", 'dsAgent', ['disabled', 'inactive', 'stopped'])
    ]
    
    for pattern, field, expected_statuses in status_patterns:
        if re.search(pattern, question_lower) and field in result[0]:
            matching_servers = sum(1 for record in result 
                                 if any(status.lower() in str(record.get(field, '')).lower() 
                                       for status in expected_statuses))
            
            if matching_servers == len(result):
                return f"**Yes** - All {len(result)} servers have {field} {'/'.join(expected_statuses)}."
            else:
                return f"**No** - Only {matching_servers} out of {len(result)} servers have {field} {'/'.join(expected_statuses)}."
    
    # Check for "any server has/is" type questions
    any_patterns = [
        (r"(any|some).*server.*(high|over|above).*cpu", 'cpu', lambda x: x > 80),
        (r"(any|some).*server.*(high|over|above).*memory", 'memory', lambda x: x > 80),
        (r"(any|some).*server.*firewall.*disabled", 'firewall', lambda x: 'disabled' in str(x).lower()),
        (r"(any|some).*server.*expired.*user", ['eisuserExpi', 'rootExpi'], lambda x: 'expired' in str(x).lower())
    ]
    
    for pattern, field, condition in any_patterns:
        if re.search(pattern, question_lower):
            if isinstance(field, list):
                # Multiple fields to check
                matching_servers = 0
                for record in result:
                    if any(condition(record.get(f, '')) for f in field):
                        matching_servers += 1
            else:
                # Single field to check
                if field in result[0]:
                    matching_servers = sum(1 for record in result 
                                         if record.get(field) is not None and condition(record.get(field)))
                else:
                    return f"**No** - Field {field} not found in data."
            
            if matching_servers > 0:
                return f"**Yes** - {matching_servers} out of {len(result)} servers match the criteria."
            else:
                return f"**No** - No servers match the criteria."
    
    # Check for existence questions
    if re.search(r"(is there|are there|exists?).*server", question_lower):
        return f"**Yes** - Found {len(result)} server(s) matching your criteria."
    
    return None

def get_comprehensive_date_context():
    """Generate extremely comprehensive date context for robust LLM understanding"""
    current_date = date.today()
    current_year = current_date.year
    current_month = current_date.month

    # Create month name mappings (case insensitive)
    month_names = {
        'january': 1, 'jan': 1, 'february': 2, 'feb': 2, 'march': 3, 'mar': 3,
        'april': 4, 'apr': 4, 'may': 5, 'june': 6, 'jun': 6,
        'july': 7, 'jul': 7, 'august': 8, 'aug': 8, 'september': 9, 'sep': 9,
        'october': 10, 'oct': 10, 'november': 11, 'nov': 11, 'december': 12, 'dec': 12
    }

    month_numbers = {v: k.title() for k, v in month_names.items() if len(k) > 3}  # Full names only

    return {
        'current_date': current_date.strftime('%Y-%m-%d'),
        'current_year': current_year,
        'current_month': current_month,
        'current_month_name': month_numbers[current_month],
        'next_year': current_year + 1,
        'prev_year': current_year - 1,
        'month_names': month_names,
        'month_numbers': month_numbers,
        'years_range': list(range(current_year - 5, current_year + 10))  # Support wide range
    }

def preprocess_question(question: str) -> str:
    """Preprocess the question to handle common patterns and extract explicit date info"""
    question_lower = question.lower().strip()

    # Extract explicit month-year patterns
    month_year_patterns = [
        r'\b(january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|august|aug|september|sep|october|oct|november|nov|december|dec)\s+(\d{4})\b',
        r'\b(\d{4})\s+(january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|august|aug|september|sep|october|oct|november|nov|december|dec)\b',
        r'\b(\d{1,2})/(\d{4})\b',  # MM/YYYY
        r'\b(\d{4})/(\d{1,2})\b'   # YYYY/MM
    ]

    date_ctx = get_comprehensive_date_context()
    extracted_info = {}

    for pattern in month_year_patterns:
        match = re.search(pattern, question_lower)
        if match:
            groups = match.groups()
            if len(groups) == 2:
                # Determine which is month and which is year
                for group in groups:
                    if group.isdigit():
                        num = int(group)
                        if 1900 <= num <= 2100:  # Year
                            extracted_info['year'] = num
                        elif 1 <= num <= 12:  # Month number
                            extracted_info['month'] = num
                    else:
                        # Month name
                        if group in date_ctx['month_names']:
                            extracted_info['month'] = date_ctx['month_names'][group]
            break

    # Add extracted information to question for LLM
    if extracted_info:
        addition = f" [EXTRACTED: "
        if 'month' in extracted_info:
            addition += f"month={extracted_info['month']} "
        if 'year' in extracted_info:
            addition += f"year={extracted_info['year']} "
        addition += "]"
        question += addition

        print(f"DEBUG - Extracted date info: {extracted_info}")
        print(f"DEBUG - Enhanced question: {question}")

    return question

def get_sql_generation_prompt():
    """Generate comprehensive SQL prompt for system compliance queries"""
    date_ctx = get_comprehensive_date_context()

    return f"""You are an expert SQL query generator for a System Compliance database.

**CURRENT DATE CONTEXT:**
- Today's date: {date_ctx['current_date']}
- Current year: {date_ctx['current_year']}
- Current month: {date_ctx['current_month']} ({date_ctx['current_month_name']})
- Next year: {date_ctx['next_year']}
- Previous year: {date_ctx['prev_year']}

**DATABASE SCHEMA:**
Table: EISHome_compliance
- id (BIGINT): Unique identifier
- ip_address (VARCHAR): Server IP address
- last_update (VARCHAR): Last update timestamp
- upTime (VARCHAR): System uptime
- server_role (VARCHAR): Server role/function
- ram (INT): RAM in GB
- cpuCore (INT): Number of CPU cores
- osVersion (VARCHAR): Operating system version
- kernelUdate (VARCHAR): Kernel update info
- aceVersion (VARCHAR): ACE version
- mqVersion (VARCHAR): MQ version
- firewall (VARCHAR): Firewall status
- rpmCount (INT): Number of RPM packages
- dsAgent (VARCHAR): Deep Security agent status
- splunk (VARCHAR): Splunk agent status
- ragent (VARCHAR): R agent status
- eisuserExpi (VARCHAR): EIS user expiry date
- rootExpi (VARCHAR): Root user expiry date
- socvaExpi (VARCHAR): Socva user expiry date
- addmitamExpi (VARCHAR): Addmitam user expiry date
- systemTime (VARCHAR): System time
- fileSystem (VARCHAR): File system info
- kernelVersion (VARCHAR): Kernel version
- cpu (INT): CPU usage/utilization  percentage
- mem_cp_update (VARCHAR): Memory/CP update info
- memory (INT): Memory usage percentage

**CRITICAL SQL GENERATION RULES:**
1. ONLY generate SELECT statements
2. Always use exact table name: EISHome_compliance
3. For text fields, use LIKE with % wildcards: column_name LIKE '%search_term%'
4. For numeric comparisons use =, >, <, >=, <= operators
5. For IP addresses, use exact match or LIKE for partial matches
6. NEVER add LIMIT unless specifically requested
7. Return ONLY the SQL query - no explanations or markdown

**COMMON QUERY PATTERNS:**

**Server Information:**
- "server with IP 192.168.1.100" â†’ SELECT * FROM EISHome_compliance WHERE ip_address = '192.168.1.100'
- "web servers" â†’ SELECT * FROM EISHome_compliance WHERE server_role LIKE '%web%'
- "database servers" â†’ SELECT * FROM EISHome_compliance WHERE server_role LIKE '%database%' OR server_role LIKE '%db%'

**Performance Queries:**
- "high CPU usage" â†’ SELECT * FROM EISHome_compliance WHERE cpu > 80
- "low memory servers" â†’ SELECT * FROM EISHome_compliance WHERE memory > 90
- "servers with more than 16GB RAM" â†’ SELECT * FROM EISHome_compliance WHERE ram > 16
- "servers with 8+ CPU cores" â†’ SELECT * FROM EISHome_compliance WHERE cpuCore >= 8

**Security Compliance:**
- "firewall disabled" â†’ SELECT * FROM EISHome_compliance WHERE firewall LIKE '%disabled%' OR firewall LIKE '%inactive%'
- "Deep Security agent not running" â†’ SELECT * FROM EISHome_compliance WHERE dsAgent NOT LIKE '%running%' AND dsAgent NOT LIKE '%active%'
- "expired users" â†’ SELECT * FROM EISHome_compliance WHERE eisuserExpi LIKE '%expired%' OR rootExpi LIKE '%expired%'
- "Splunk agent issues" â†’ SELECT * FROM EISHome_compliance WHERE splunk NOT LIKE '%running%'

**System Versions:**
- "CentOS servers" â†’ SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%CentOS%'
- "old kernel versions" â†’ SELECT * FROM EISHome_compliance WHERE kernelVersion LIKE '%3.%' OR kernelVersion LIKE '%2.%'
- "ACE version 8" â†’ SELECT * FROM EISHome_compliance WHERE aceVersion LIKE '%8.%'

**Yes/No Questions (return all relevant data):**
- "do all servers have same kernel version" â†’ SELECT kernelVersion FROM EISHome_compliance
- "does any server have firewall disabled" â†’ SELECT * FROM EISHome_compliance
- "are all servers running Deep Security" â†’ SELECT dsAgent FROM EISHome_compliance

**Aggregation Queries:**
- "count servers by role" â†’ SELECT server_role, COUNT(*) as count FROM EISHome_compliance GROUP BY server_role
- "average RAM per server role" â†’ SELECT server_role, AVG(ram) as avg_ram FROM EISHome_compliance GROUP BY server_role
- "total servers" â†’ SELECT COUNT(*) as total_servers FROM EISHome_compliance

**Compliance Status:**
- "non-compliant servers" â†’ SELECT * FROM EISHome_compliance WHERE firewall NOT LIKE '%active%' OR dsAgent NOT LIKE '%running%'
- "servers needing updates" â†’ SELECT * FROM EISHome_compliance WHERE kernelUdate LIKE '%available%' OR kernelUdate LIKE '%pending%'

**USER QUESTION:** {{question}}
"""

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.system_compliance_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str) -> str:
    """Enhanced SQL cleaning with better error handling"""
    print(f"DEBUG - Raw SQL input: {repr(raw_sql)}")
    raw_sql = sqlparse.format(raw_sql, strip_comments=True).strip()
    print(f"DEBUG - Validating SQL: {raw_sql}")

    # Handle common LLM response patterns
    if "i cannot" in raw_sql.lower() or "i can't" in raw_sql.lower():
        print("DEBUG - LLM refused to generate SQL")
        return "ERROR: LLM refused to generate SQL"

    # Extract from code blocks
    code_block_match = re.search(r"``````", raw_sql, re.DOTALL | re.IGNORECASE)
    if code_block_match:
        sql = code_block_match.group(1).strip()
        print(f"DEBUG - Extracted from code block: {sql}")
    else:
        sql = raw_sql.strip()

    # Remove common prefixes/suffixes
    sql = re.sub(r'^(here is|here\'s|sql query|query|the query is)?\s*:?\s*', '', sql, flags=re.IGNORECASE)
    sql = re.sub(r'\s*;?\s*$', '', sql)

    # Find SELECT statement
    select_match = re.search(r'(SELECT\s+.*?)(?:\n\s*$|$)', sql, re.IGNORECASE | re.DOTALL)
    if select_match:
        sql = select_match.group(1).strip()
        print(f"DEBUG - Extracted SELECT statement: {sql}")

    # Handle specific server ID queries
    if not sql.upper().startswith('SELECT') and re.search(r'\bserver\b.*\b\d+\b', raw_sql.lower()):
        server_id_match = re.search(r'\b(\d+)\b', raw_sql)
        if server_id_match:
            server_id = server_id_match.group(1)
            sql = f"SELECT * FROM EISHome_compliance WHERE id = {server_id}"
            print(f"DEBUG - Generated server ID query: {sql}")

    # Handle IP address queries
    ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    ip_match = re.search(ip_pattern, raw_sql)
    if ip_match and not sql.upper().startswith('SELECT'):
        ip_address = ip_match.group(0)
        sql = f"SELECT * FROM EISHome_compliance WHERE ip_address = '{ip_address}'"
        print(f"DEBUG - Generated IP address query: {sql}")

    # Fix text field searches (convert = to LIKE for text fields)
    text_fields = ['ip_address', 'server_role', 'osVersion', 'aceVersion', 'mqVersion',
                   'firewall', 'dsAgent', 'splunk', 'ragent', 'kernelVersion', 'fileSystem']

    for field in text_fields:
        # Convert = to LIKE for text fields (except for exact IP matches)
        if field != 'ip_address' or not re.search(ip_pattern, sql):
            sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
            sql = re.sub(f"({field})\\s*=\\s*\"([^\"]*)\"", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)

    # Remove unwanted LIMIT clauses
    sql = re.sub(r'\s+LIMIT\s+\d+\s*$', '', sql, flags=re.IGNORECASE)

    # Final cleanup
    sql = sql.strip()

    print(f"DEBUG - Final cleaned SQL: {sql}")
    return sql

def validate_and_fix_sql(sql: str) -> tuple[str, bool]:
    """Validate SQL and attempt to fix common issues"""
    fixed_sql = sqlparse.format(sql, strip_comments=True).strip()
    print(f"DEBUG - Validating SQL: {fixed_sql}")
    return fixed_sql, True

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Enhanced result formatting for system compliance data with yes/no support"""
    # Check if this is a yes/no question first
    if detect_yes_no_question(question):
        yes_no_answer = analyze_for_yes_no_answer(question, result)
        if yes_no_answer:
            # For yes/no questions, provide the answer followed by supporting details
            response = yes_no_answer + "\n\n"
            
            # Add some supporting details if there are results
            if result and len(result) <= 10:
                response += "ğŸ“‹ **Supporting Details:**\n"
                response += format_query_results_tabular(result)
            elif result and len(result) > 10:
                response += f"ğŸ“‹ **Supporting Details** (showing first 5 of {len(result)} servers):\n"
                response += format_query_results_tabular(result[:5])
                response += f"\n... and {len(result) - 5} more servers."
            
            return response
    
    # Continue with original formatting for non-yes/no questions
    if not result:
        return "I couldn't find any system compliance records matching your criteria."

    # Handle single value results (like COUNT)
    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} servers matching your criteria."
        else:
            return f"The result is: {value}"

    # Handle single record
    if len(result) == 1:
        record = result[0]
        response = f"I found 1 server:\n\n"

        # Format key information with icons
        key_fields = ['id', 'ip_address', 'server_role', 'osVersion', 'upTime', 'ram', 'cpuCore',
                     'firewall', 'dsAgent', 'splunk', 'cpu', 'memory', 'kernelVersion']

        icons = {
            'id': 'ğŸ†”', 'ip_address': 'ğŸŒ', 'server_role': 'ğŸ·ï¸', 'osVersion': 'ğŸ’¿',
            'upTime': 'â±ï¸', 'ram': 'ğŸ§ ', 'cpuCore': 'âš¡', 'firewall': 'ğŸ”¥',
            'dsAgent': 'ğŸ›¡ï¸', 'splunk': 'ğŸ“Š', 'cpu': 'ğŸ–¥ï¸', 'memory': 'ğŸ’¾',
            'kernelVersion': 'ğŸ”§'
        }

        for field in key_fields:
            if field in record and record[field] is not None:
                icon = icons.get(field, 'â€¢')
                field_name = field.replace('_', ' ').title()
                value = record[field]

                # Add units for specific fields
                if field == 'ram':
                    value = f"{value} GB"
                elif field == 'cpu' and isinstance(value, int):
                    value = f"{value}%"
                elif field == 'memory' and isinstance(value, int):
                    value = f"{value}%"

                response += f"{icon} {field_name}: {value}\n"

        return response.strip()

    # Handle multiple records
    response = f"I found {len(result)} servers matching your criteria:\n\n"

    # Add summary statistics if available
    if any(field in result[0] for field in ['server_role', 'osVersion', 'firewall']):
        # Server role summary
        if 'server_role' in result[0]:
            role_counts = {}
            for record in result:
                role = record.get('server_role', 'Unknown')
                role_counts[role] = role_counts.get(role, 0) + 1

            if len(role_counts) > 1:
                response += "ğŸ·ï¸ Server Role Summary:\n"
                for role, count in sorted(role_counts.items()):
                    response += f"   â€¢ {role}: {count} servers\n"
                response += "\n"

        # Security status summary
        if 'firewall' in result[0] and 'dsAgent' in result[0]:
            firewall_active = sum(1 for r in result if r.get('firewall', '').lower() in ['active', 'enabled', 'running'])
            ds_active = sum(1 for r in result if r.get('dsAgent', '').lower() in ['active', 'running'])

            response += "ğŸ”’ Security Summary:\n"
            response += f"   â€¢ Firewall Active: {firewall_active}/{len(result)} servers\n"
            response += f"   â€¢ Deep Security Active: {ds_active}/{len(result)} servers\n"
            response += "\n"

    # Show detailed results based on count
    if len(result) <= 10:
        response += "ğŸ“‹ Detailed Results:\n"
        response += format_query_results_tabular(result)
    elif len(result) <= 50:
        response += f"ğŸ“‹ First 10 Results (of {len(result)} total):\n"
        response += format_query_results_tabular(result[:10])
        response += f"\n... and {len(result) - 10} more servers."
    else:
        response += f"ğŸ“‹ Sample Results (showing 5 of {len(result)} total):\n"
        response += format_query_results_tabular(result[:5])
        response += f"\n... and {len(result) - 5} more servers."

    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Format results in a clean table for system compliance"""
    if not result:
        return "No records found."

    # Select most important columns for display
    important_cols = ['id', 'ip_address', 'server_role', 'osVersion', 'ram', 'cpuCore', 'firewall', 'dsAgent']
    available_cols = [col for col in important_cols if col in result[0]]

    if not available_cols:
        available_cols = list(result[0].keys())[:8]  # First 8 columns

    output = []

    # Calculate column widths
    col_widths = {}
    for col in available_cols:
        max_width = len(col)
        for row in result:
            if row.get(col):
                max_width = max(max_width, len(str(row[col])))
        col_widths[col] = min(max_width, 30)  # Max 30 chars per column

    # Header
    header = " | ".join(col.ljust(col_widths[col]) for col in available_cols)
    separator = "-+-".join("-" * col_widths[col] for col in available_cols)
    output.append(header)
    output.append(separator)

    # Rows
    for row in result:
        formatted_row = " | ".join(
            str(row.get(col, 'NULL'))[:col_widths[col]-3] + "..."
            if len(str(row.get(col, 'NULL'))) > col_widths[col]
            else str(row.get(col, 'NULL')).ljust(col_widths[col])
            for col in available_cols
        )
        output.append(formatted_row)

    return "\n".join(output)

class SystemComplianceAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the System Compliance Assistant"""
        try:
            # Initialize LLM with better parameters
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)

            # Set up database connection
            db_cfg = COMPLIANCE_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"

            # Connect to database
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=COMPLIANCE_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 3600,
                    "connect_args": {
                        "connect_timeout": 30,
                        "read_timeout": 30,
                        "charset": "utf8mb4"
                    }
                }
            )

            # Create query chain
            chain = create_sql_query_chain(self.llm, db_for_llm)

            # Create direct connection for executing queries
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=30,
                read_timeout=30
            )

            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': COMPLIANCE_DB_CONFIG
            }

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def query_system_compliance(self, question: str) -> str:
        """Enhanced query processing with better error handling"""
        if not self.db_handler:
            return "âŒ System Compliance database not available."

        try:
            print(f"DEBUG - Original question: {question}")

            # Check if it's a yes/no question
            is_yes_no = detect_yes_no_question(question)
            print(f"DEBUG - Is yes/no question: {is_yes_no}")

            # Preprocess question to extract date information
            enhanced_question = preprocess_question(question)

            # Get date context
            date_ctx = get_comprehensive_date_context()

            # Create comprehensive context for the LLM
            context_info = f"""
CURRENT DATE CONTEXT:
- Today: {date_ctx['current_date']}
- Current Year: {date_ctx['current_year']}
- Next Year: {date_ctx['next_year']}

IMPORTANT INSTRUCTIONS:
- For server searches, use ip_address, server_role, or id fields
- For performance queries, use ram, cpuCore, cpu, memory fields
- For security compliance, use firewall, dsAgent, splunk fields
- For version info, use osVersion, kernelVersion, aceVersion, mqVersion
- Use LIKE for text searches and exact matches for numbers/IPs
- For expired users, check eisuserExpi, rootExpi, socvaExpi, addmitamExpi fields
- For yes/no questions about "all servers same X", return all relevant data to analyze
- Every time see the question and generate an answer to the question likewise

QUESTION: {enhanced_question}
"""

            # Generate SQL using the chain
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    print(f"DEBUG - Attempt {attempt + 1} generating SQL")
                    raw_sql = self.db_handler['chain'].invoke({"question": context_info})
                    print(f"DEBUG - Raw SQL from LLM: {repr(raw_sql)}")
                    break
                except Exception as e:
                    print(f"DEBUG - SQL generation failed on attempt {attempt + 1}: {e}")
                    if attempt == max_retries - 1:
                        return f"âŒ Failed to generate SQL query after {max_retries} attempts: {str(e)}"
                    continue

            # Clean and validate SQL
            sql = clean_and_fix_sql(raw_sql)
            sql, is_valid = validate_and_fix_sql(sql)
            if sql[-1] != ";":
                sql += ";"

            if not is_valid:
                return f"âŒ Invalid SQL query generated. Raw: {repr(raw_sql)}\nCleaned: {sql}"

            print(f"DEBUG - Final SQL: {sql}")
            logger.info(f"Executing SQL: {sql}")

            # Execute query with error handling
            try:
                with self.db_handler['connection'].cursor() as cursor:
                    cursor.execute(sql)
                    result = cursor.fetchall()
                    print(f"DEBUG - Query returned {len(result)} rows")

                    if not result and not is_yes_no:
                        suggestions = self._generate_suggestions(question, sql)
                        return f"I couldn't find any system compliance records matching your criteria.\n\n{suggestions}"
                    elif not result and is_yes_no:
                        return "**No** - No servers found matching the criteria."

                    # Format and return results
                    return format_query_results_natural(result, question)

            except pymysql.Error as db_error:
                error_code = getattr(db_error, 'args', [None])[0] if hasattr(db_error, 'args') else None
                error_msg = f"âŒ Database Error (Code: {error_code}): {str(db_error)}\n"
                error_msg += f"SQL: {sql}\n"

                # Try to provide helpful suggestions based on error type
                if "syntax error" in str(db_error).lower():
                    error_msg += "This appears to be a SQL syntax error. "
                elif "unknown column" in str(db_error).lower():
                    error_msg += "This appears to be a column name error. "
                elif "table" in str(db_error).lower():
                    error_msg += "This appears to be a table name error. "

                error_msg += "Please try rephrasing your question."
                logger.error(f"Database error: {db_error}\nSQL: {sql}")
                return error_msg

        except Exception as e:
            error_msg = f"âŒ Error processing request: {str(e)}\n"
            error_msg += "Please try rephrasing your question."
            logger.error(f"Query processing error: {e}\n{traceback.format_exc()}")
            return error_msg

    def _generate_suggestions(self, question: str, sql: str) -> str:
        """Generate helpful suggestions when no results are found"""
        suggestions = "ğŸ’¡ Suggestions:\n"
        suggestions += "â€¢ Try using broader search terms\n"
        suggestions += "â€¢ Check server roles (web, database, application, etc.)\n"
        suggestions += "â€¢ Verify IP address format (e.g., 192.168.1.100)\n"
        suggestions += "â€¢ Check security status terms (active, running, disabled)\n"

        if "firewall" in question.lower():
            suggestions += "â€¢ Try terms like 'active', 'disabled', 'inactive' for firewall status\n"

        if "memory" in question.lower() or "cpu" in question.lower():
            suggestions += "â€¢ Use percentage values (e.g., >80 for high usage)\n"

        suggestions += f"\nğŸ” Query executed: {sql}"
        return suggestions

    def process_question(self, question: str) -> str:
        """Process questions with enhanced error handling"""
        if not self.initialized and not self.initialize():
            return "âŒ System Compliance Assistant initialization failed. Please check database connection."

        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."

        # Add to chat history
        self.chat_history.append(f"User: {question}")

        # Get response
        response = self.query_system_compliance(question)

        # Add response to history
        self.chat_history.append(f"Assistant: {response}")

        return response

    def start_interactive_session(self, query):
        """Process single query with comprehensive error handling"""
        if not self.initialize():
            return "âŒ Failed to initialize System Compliance Assistant. Check database connection."

        try:
            if query.lower() in ['exit', 'quit', 'q']:
                return "ğŸ‘‹ Session ended."

            print("ğŸ” Processing your query...")
            response = self.process_question(query)
            return response

        except KeyboardInterrupt:
            return "ğŸ‘‹ Session interrupted."
        except Exception as e:
            error_msg = f"âŒ Session error: {str(e)}"
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return error_msg
        finally:
            # Clean up database connection
            try:
                if (self.db_handler and
                    self.db_handler.get('connection') and
                    hasattr(self.db_handler['connection'], 'open') and
                    self.db_handler['connection'].open):
                    self.db_handler['connection'].close()
            except Exception as cleanup_error:
                print(f"DEBUG - Cleanup error: {cleanup_error}")
                pass

def ComplianceMain(query):
    """Main function to process System Compliance queries with enhanced robustness"""
    print("ğŸš€ Starting System Compliance Assistant...")
    assistant = SystemComplianceAssistant()
    result = assistant.start_interactive_session(query)
    print("âœ… Query processing complete.")
    return result

# Interactive usage
if __name__ == "__main__":
    print("ğŸš€ System Compliance Assistant")
    print("=" * 50)
    print("Ask questions about your system compliance database in natural language.")
    print("Examples:")
    print("  â€¢ 'Show servers with high CPU usage'")
    print("  â€¢ 'List all database servers'")
    print("  â€¢ 'Do all servers have the same kernel version?'")
    print("  â€¢ 'Are there any servers with firewall disabled?'")
    print("  â€¢ 'Does every server have Deep Security running?'")
    print("  â€¢ 'Count servers by role'")
    print("\nType 'exit' to quit.\n")

    while True:
        try:
            user_query = input("ğŸ” Enter your query: ").strip()

            if not user_query:
                continue

            if user_query.lower() in ['exit', 'quit', 'q']:
                print("ğŸ‘‹ Goodbye!")
                break

            print("\nğŸ”„ Processing your query...")
            result = ComplianceMain(user_query)
            print(f"\nğŸ“Š Results:\n{result}\n")
            print("-" * 50)

        except KeyboardInterrupt:
            print("\nğŸ‘‹ Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {str(e)}")
            print("Please try rephrasing your question.\n")
