import os
import re
import traceback
import pymysql
import sqlparse
from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

# --- Configuration ---

# [cite: 58] Database connection details
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "root123",
    "database": "EIS_n"
}

# LLM model to use
LLM_MODEL = "mistral:7b-instruct-q4_K_M"

# --- Database Setup ---

def get_db_connection():
    """Establishes and returns a SQLAlchemy engine for the database."""
    uri = f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}"
    return create_engine(uri)

# Instantiate the database engine
try:
    db_engine = get_db_connection()
    # Test connection
    with db_engine.connect() as connection:
        print("‚úÖ Database connection successful.")
    db = SQLDatabase(engine=db_engine)
except Exception as e:
    print(f"‚ùå Database connection failed. Please check your credentials and ensure the MySQL server is running.")
    print(f"Error: {e}")
    exit()

# --- LLM and Prompt Setup ---

# Initialize the Ollama LLM
llm = OllamaLLM(model=LLM_MODEL)

# [cite: 27, 29, 30] Detailed prompt template for generating SQL queries
# This prompt includes schema details, rules, and examples to guide the LLM.
sql_prompt_template = """### Instructions
You are an AI assistant that generates read-only MySQL queries for a database with the following schema.
Your ONLY output should be the MySQL query. Do not add any explanation, commentary, or markdown formatting like ```sql.

### Rules
1.   **IMPORTANT**: You MUST only generate read-only `SELECT` queries. Never generate `UPDATE`, `DELETE`, `INSERT`, `DROP`, or any other write-modifying queries.
2.  The table name is `EISHome_compliance`.
3.  Use `LIKE` for string comparisons to allow for partial matches.
4.  Analyze the user's question to infer the correct column and values for the `WHERE` clause.

### Table Schema: `EISHome_compliance`
- id (bigint): Unique identifier for each entry.
- ip_address (varchar): IP address of the server (e.g., '192.168.1.10').
- last_update (varchar): Last update timestamp (e.g., '2025-08-08 10:00:00').
- upTime (varchar): Server uptime (e.g., '30 days').
- server_role (varchar): Role of the server (e.g., 'Application Server', 'Database Server').
- [cite: 29] ram (int): RAM in GB (e.g., 16 for 16GB).
- [cite: 30] cpuCore (int): Number of CPU cores (e.g., 8).
- [cite: 29, 31, 37] osVersion (varchar): Operating system version (e.g., 'Red Hat Enterprise Linux 9.2').
- [cite: 31, 37] kernelVersion (varchar): Linux kernel version (e.g., '5.14.0-284.11.1.el9_2.x86_64').
- [cite: 29] firewall (varchar): Firewall status (e.g., 'enabled', 'disabled').
- rpmCount (int): Count of installed RPM packages.
- [cite: 29] dsAgent (varchar): Deep Security agent status (e.g., 'active').
- [cite: 29] splunk (varchar): Splunk agent status (e.g., 'installed').

### Query Examples
- Question: "What is the OS version for the server with IP 10.0.2.5?"
  Query: SELECT osVersion FROM EISHome_compliance WHERE ip_address = '10.0.2.5';
- Question: "show me all servers with more than 8 cores"
  [cite: 30] Query: SELECT * FROM EISHome_compliance WHERE cpuCore > 8;
- Question: "are there any servers with firewall disabled?"
  [cite: 94] Query: SELECT id FROM EISHome_compliance WHERE firewall = 'disabled';

### User Question
{question}

### Your MySQL Query
"""

SQL_PROMPT = PromptTemplate.from_template(sql_prompt_template)

# Prompt template for explaining the results to the user
explanation_prompt_template = """### Instructions
You are an AI assistant. A user asked a question, a database query was run, and you have the results.
Your task is to provide a clear, human-like explanation of the data as an answer to the user's question.
If the result is empty, inform the user that no matching records were found. Do not mention the database or the query.

### User's Question
{question}

### Database Result
{result}

### Your Answer
"""

EXPLANATION_PROMPT = PromptTemplate.from_template(explanation_prompt_template)


# --- Core Functions ---

def is_readonly_query(sql_query: str) -> bool:
    """
    [cite: 2, 83] Checks if the generated SQL query is a read-only SELECT statement.
    """
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return False
    # Check the first statement's type
    return parsed[0].get_type() == 'SELECT'

def get_yes_no_answer(db_result: list) -> str:
    """
    Determines the 'Yes' or 'No' answer based on whether the query returned any data.
    An empty result (e.g., []) means 'No', otherwise 'Yes'.
    """
    # The db.run() method returns a string representation of a list of tuples.
    # An empty result looks like '[]' or an empty string.
    if db_result and db_result != '[]':
        return "Yes"
    else:
        return "No"

# --- LangChain Chains ---

# Chain to generate the SQL query
sql_generation_chain = (
    RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
    | SQL_PROMPT
    | llm
    | StrOutputParser()
)

# Chain to explain the results
explanation_chain = EXPLANATION_PROMPT | llm | StrOutputParser()


# --- Main Application Logic ---

def main():
    """Main function to run the chatbot terminal interface."""
    print("\n--- AI Database Chatbot ---")
    print("Ask questions about your IT infrastructure. Type 'exit' to quit.")

    #  Words that trigger a "Yes/No" response
    yes_no_starters = ('is', 'are', 'do', 'does', 'did', 'has', 'have')

    while True:
        try:
            user_question = input("\n> ")
            if user_question.lower().strip() == 'exit':
                print("Goodbye!")
                break

            # Determine response type based on the question's first word
            is_yes_no_question = user_question.lower().strip().startswith(yes_no_starters)

            # 1. Generate SQL Query
            print("ü§ñ Thinking...")
            generated_sql = sql_generation_chain.invoke({"question": user_question})
            
            # Clean up potential markdown formatting from LLM output
            generated_sql = generated_sql.strip().replace("```sql", "").replace("```", "").strip()
            print(f"üîç Generated SQL: {generated_sql}")

            # 2. Validate the Query
            if not is_readonly_query(generated_sql):
                print("‚ö†Ô∏è Error: Only read-only queries are allowed. Aborting.")
                continue

            # 3. Execute the Query
            db_result = db.run(generated_sql)

            # 4. Generate the Final Answer
            if is_yes_no_question:
                answer = get_yes_no_answer(db_result)
                print(f"\nü§ñ Answer: {answer}")
            else:
                # For descriptive questions, use the explanation chain
                explanation = explanation_chain.invoke({"question": user_question, "result": db_result})
                print(f"\nü§ñ Answer: {explanation}")

        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            print("Please try rephrasing your question.")

if __name__ == "__main__":
    main()
